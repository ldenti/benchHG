diff --git a/src/include/align.hpp b/src/include/align.hpp
index e9ea48a..8c84f62 100644
--- a/src/include/align.hpp
+++ b/src/include/align.hpp
@@ -11,829 +11,760 @@
 #include <x86intrin.h>
 #include <zlib.h>
 
-#include "graphLoad.hpp"
+#include "base_types.hpp"
 #include "csr_char.hpp"
+#include "graphLoad.hpp"
 #include "graph_iter.hpp"
-#include "base_types.hpp"
 #include "utils.hpp"
 
 #if defined(PASGAL_ENABLE_AVX512) || defined(PASGAL_ENABLE_AVX2)
 #include "align_vectorized.hpp"
 #endif
 
-//External includes
-#include "kseq/kseq.h"
-
-KSEQ_INIT(gzFile, gzread)
-
-#define psgl_max(a,b) (((a)>(b))?(a):(b))
-
-namespace psgl
-{
-  /**
-   * @brief                         execute first phase of alignment i.e. compute DP and 
-   *                                find locations of the best alignment of each read
-   * @param[in]   readSet           vector of input query sequences to align
-   * @param[in]   graph
-   * @param[in]   parameters        input parameters
-   * @param[out]  bestScoreVector   vector to keep value and location of best scores,
-   *                                vector size is same as count of the reads
-   * @note                          reverse complement of the read is not handled here
-   */
-  void alignToDAGLocal_Phase1_scalar( const std::vector<std::string> &readSet,
-                                      const CSR_char_container &graph,
-                                      const Parameters &parameters, 
-                                      std::vector< BestScoreInfo > &bestScoreVector)
-  {
-    assert (bestScoreVector.size() == readSet.size());
+#ifndef psgl_max
+#define psgl_max(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+
+namespace psgl {
+/**
+ * @brief                         execute first phase of alignment i.e. compute
+ * DP and find locations of the best alignment of each read
+ * @param[in]   readSet           vector of input query sequences to align
+ * @param[in]   graph
+ * @param[in]   parameters        input parameters
+ * @param[out]  bestScoreVector   vector to keep value and location of best
+ * scores, vector size is same as count of the reads
+ * @note                          reverse complement of the read is not handled
+ * here
+ */
+inline void alignToDAGLocal_Phase1_scalar(
+    const std::vector<std::string> &readSet, const CSR_char_container &graph,
+    const Parameters &parameters, std::vector<BestScoreInfo> &bestScoreVector) {
+  assert(bestScoreVector.size() == readSet.size());
 
 #ifdef VTUNE_SUPPORT
-    __itt_resume();
+  __itt_resume();
 #endif
 
-    auto tick1 = __rdtsc();
+  // auto tick1 = __rdtsc();
 
-#pragma omp parallel
-    {
+#pragma omp parallel num_threads(parameters.threads)
+  {
 
-      //initialize matrix of size 2 x width, init with zero
-      //we will keep re-using rows to keep memory-usage low
-      std::vector< std::vector<int32_t> > matrix(2, std::vector<int32_t>(graph.numVertices, 0));
+    // initialize matrix of size 2 x width, init with zero
+    // we will keep re-using rows to keep memory-usage low
+    std::vector<std::vector<int32_t>> matrix(
+        2, std::vector<int32_t>(graph.numVertices, 0));
 
 #pragma omp for schedule(dynamic)
-      for (size_t readno = 0; readno < readSet.size(); readno++)
-      {
-        //reset buffer
-        std::fill(matrix[1].begin(), matrix[1].end(), 0);
-
-        auto readLength = readSet[readno].length();
-
-        int32_t bestScore = 0;
-        int32_t bestRow = 0, bestCol = 0;
-
-        //iterate over characters in read
-        for (int32_t i = 0; i < readLength; i++)
-        {
-          //iterate over characters in reference graph
-          for (int32_t j = 0; j < graph.numVertices; j++)
-          {
-            //current reference character
-            char curChar = graph.vertex_label[j];
-
-            int32_t currentMax = 0;
-
-            //see if query and ref. character match
-            int32_t matchScore = curChar == readSet[readno][i] ? parameters.match : -1 * parameters.mismatch;
-
-            //match-mismatch edit
-            currentMax = psgl_max (currentMax, matchScore);   //local alignment can also start with a match at this char
-
-            for(auto k = graph.offsets_in[j]; k < graph.offsets_in[j+1]; k++)
-            {
-              //paths with match mismatch edit
-              currentMax = psgl_max (currentMax, matrix[(i-1) & 1][ graph.adjcny_in[k] ] + matchScore);
-              //'& 1' is same as doing modulo 2
-
-              //paths with deletion edit
-              currentMax = psgl_max (currentMax, matrix[i & 1][ graph.adjcny_in[k] ] - parameters.del);
-            }
+    for (size_t readno = 0; readno < readSet.size(); readno++) {
+      // reset buffer
+      std::fill(matrix[1].begin(), matrix[1].end(), 0);
+
+      auto readLength = readSet[readno].length();
+
+      int32_t bestScore = 0;
+      int32_t bestRow = 0, bestCol = 0;
+
+      // iterate over characters in read
+      for (int32_t i = 0; i < readLength; i++) {
+        // iterate over characters in reference graph
+        for (int32_t j = 0; j < graph.numVertices; j++) {
+          // current reference character
+          char curChar = graph.vertex_label[j];
+
+          int32_t currentMax = 0;
+
+          // see if query and ref. character match
+          int32_t matchScore = curChar == readSet[readno][i]
+                                   ? parameters.match
+                                   : -1 * parameters.mismatch;
+
+          // match-mismatch edit
+          currentMax = psgl_max(currentMax,
+                                matchScore); // local alignment can also start
+                                             // with a match at this char
+
+          for (auto k = graph.offsets_in[j]; k < graph.offsets_in[j + 1]; k++) {
+            // paths with match mismatch edit
+            currentMax =
+                psgl_max(currentMax,
+                         matrix[(i - 1) & 1][graph.adjcny_in[k]] + matchScore);
+            //'& 1' is same as doing modulo 2
+
+            // paths with deletion edit
+            currentMax = psgl_max(
+                currentMax, matrix[i & 1][graph.adjcny_in[k]] - parameters.del);
+          }
 
-            //insertion edit
-            currentMax = psgl_max( currentMax, matrix[(i-1) & 1][j] - parameters.ins );
+          // insertion edit
+          currentMax =
+              psgl_max(currentMax, matrix[(i - 1) & 1][j] - parameters.ins);
 
-            matrix[i & 1][j] = currentMax;
+          matrix[i & 1][j] = currentMax;
 
-            bestScore = psgl_max (bestScore, currentMax);
+          bestScore = psgl_max(bestScore, currentMax);
 
-            //Update best score observed till now
-            if (bestScore == currentMax)
-            {
-              bestScore = currentMax; bestCol = j; bestRow = i;
-            }
-          } // end of row computation
-        } // end of DP
+          // Update best score observed till now
+          if (bestScore == currentMax) {
+            bestScore = currentMax;
+            bestCol = j;
+            bestRow = i;
+          }
+        } // end of row computation
+      }   // end of DP
 
-        bestScoreVector[readno].score = bestScore;
-        bestScoreVector[readno].refColumnEnd = bestCol;
-        bestScoreVector[readno].qryRowEnd = bestRow;
+      bestScoreVector[readno].score = bestScore;
+      bestScoreVector[readno].refColumnEnd = bestCol;
+      bestScoreVector[readno].qryRowEnd = bestRow;
 
-      } // all reads done
-    } //end of omp parallel
+    } // all reads done
+  }   // end of omp parallel
 
-    auto tick2 = __rdtsc();
+  // auto tick2 = __rdtsc();
 
-    std::cout << "TIMER, psgl::alignToDAGLocal_Phase1_scalar, CPU cycles spent in phase 1 = " << tick2 - tick1 
-      << ", estimated time (s) = " << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << "\n";
+  // std::cout << "TIMER, psgl::alignToDAGLocal_Phase1_scalar, CPU cycles spent "
+  //              "in phase 1 = "
+  //           << tick2 - tick1 << ", estimated time (s) = "
+  //           << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << "\n";
 
 #ifdef VTUNE_SUPPORT
-    __itt_pause();
+  __itt_pause();
 #endif
+}
 
-  }
-
-
-  /**
-   * @brief                         execute first phase of alignment in reverse direction (right to left)
-   *                                i.e. compute reverse DP so as to find
-   *                                find begin location of the best alignment of each read
-   * @param[in]   readSet           vector of input query sequences to align
-   * @param[in]   graph
-   * @param[in]   parameters        input parameters
-   * @param[out]  bestScoreVector   vector to keep value and location of best scores,
-   *                                vector size is same as count of the reads
-   * @note                          reverse complement of the read is not handled here
-   */
-  void alignToDAGLocal_Phase1_rev_scalar( const std::vector<std::string> &readSet,
-                                          const CSR_char_container &graph,
-                                          const Parameters &parameters, 
-                                          std::vector< BestScoreInfo > &bestScoreVector)
-  {
-    assert (bestScoreVector.size() == readSet.size());
+/**
+ * @brief                         execute first phase of alignment in reverse
+ * direction (right to left) i.e. compute reverse DP so as to find find begin
+ * location of the best alignment of each read
+ * @param[in]   readSet           vector of input query sequences to align
+ * @param[in]   graph
+ * @param[in]   parameters        input parameters
+ * @param[out]  bestScoreVector   vector to keep value and location of best
+ * scores, vector size is same as count of the reads
+ * @note                          reverse complement of the read is not handled
+ * here
+ */
+inline void alignToDAGLocal_Phase1_rev_scalar(
+    const std::vector<std::string> &readSet, const CSR_char_container &graph,
+    const Parameters &parameters, std::vector<BestScoreInfo> &bestScoreVector) {
+  assert(bestScoreVector.size() == readSet.size());
 
 #ifdef VTUNE_SUPPORT
-    __itt_resume();
+  __itt_resume();
 #endif
 
-    auto tick1 = __rdtsc();
+  // auto tick1 = __rdtsc();
 
-#pragma omp parallel
-    {
+#pragma omp parallel num_threads(parameters.threads)
+  {
 
-      //initialize matrix of size 2 x width, init with zero
-      //we will keep re-using rows to keep memory-usage low
-      std::vector< std::vector<int32_t> > matrix(2, std::vector<int32_t>(graph.numVertices, 0));
+    // initialize matrix of size 2 x width, init with zero
+    // we will keep re-using rows to keep memory-usage low
+    std::vector<std::vector<int32_t>> matrix(
+        2, std::vector<int32_t>(graph.numVertices, 0));
 
 #pragma omp for schedule(dynamic)
-      for (size_t readno = 0; readno < readSet.size(); readno++)
-      {
-        //reset buffer
-        std::fill(matrix[1].begin(), matrix[1].end(), 0);
-
-        auto readLength = readSet[readno].length();
-
-        int32_t bestScore = 0;
-        int32_t bestRow = 0, bestCol = 0;
-
-        //iterate over characters in read
-        for (int32_t i = 0; i < readLength; i++)
-        {
-          //iterate over characters in reference graph
-          for (int32_t j = graph.numVertices - 1; j >= 0; j--)
-          {
-            //current reference character
-            char curChar = graph.vertex_label[j];
-
-            int32_t currentMax = 0;
-
-            //see if query and ref. character match
-            int32_t matchScore = curChar == readSet[readno][i] ? parameters.match : -1 * parameters.mismatch;
-
-            //match-mismatch edit
-            currentMax = psgl_max (currentMax, matchScore);   //local alignment can also start with a match at this char
-
-            for(auto k = graph.offsets_out[j]; k < graph.offsets_out[j+1]; k++)
-            {
-              //paths with match mismatch edit
-              currentMax = psgl_max (currentMax, matrix[(i-1) & 1][ graph.adjcny_out[k] ] + matchScore);
-              //'& 1' is same as doing modulo 2
-
-              //paths with deletion edit
-              currentMax = psgl_max (currentMax, matrix[i & 1][ graph.adjcny_out[k] ] - parameters.del);
-            }
+    for (size_t readno = 0; readno < readSet.size(); readno++) {
+      // reset buffer
+      std::fill(matrix[1].begin(), matrix[1].end(), 0);
+
+      auto readLength = readSet[readno].length();
+
+      int32_t bestScore = 0;
+      int32_t bestRow = 0, bestCol = 0;
+
+      // iterate over characters in read
+      for (int32_t i = 0; i < readLength; i++) {
+        // iterate over characters in reference graph
+        for (int32_t j = graph.numVertices - 1; j >= 0; j--) {
+          // current reference character
+          char curChar = graph.vertex_label[j];
+
+          int32_t currentMax = 0;
+
+          // see if query and ref. character match
+          int32_t matchScore = curChar == readSet[readno][i]
+                                   ? parameters.match
+                                   : -1 * parameters.mismatch;
+
+          // match-mismatch edit
+          currentMax = psgl_max(currentMax,
+                                matchScore); // local alignment can also start
+                                             // with a match at this char
+
+          for (auto k = graph.offsets_out[j]; k < graph.offsets_out[j + 1];
+               k++) {
+            // paths with match mismatch edit
+            currentMax =
+                psgl_max(currentMax,
+                         matrix[(i - 1) & 1][graph.adjcny_out[k]] + matchScore);
+            //'& 1' is same as doing modulo 2
+
+            // paths with deletion edit
+            currentMax =
+                psgl_max(currentMax,
+                         matrix[i & 1][graph.adjcny_out[k]] - parameters.del);
+          }
 
-            //insertion edit
-            currentMax = psgl_max( currentMax, matrix[(i-1) & 1][j] - parameters.ins );
+          // insertion edit
+          currentMax =
+              psgl_max(currentMax, matrix[(i - 1) & 1][j] - parameters.ins);
 
-            matrix[i & 1][j] = currentMax;
+          matrix[i & 1][j] = currentMax;
 
-            bestScore = psgl_max (bestScore, currentMax);
+          bestScore = psgl_max(bestScore, currentMax);
 
-            //Update best score observed till now
-            if (bestScore == currentMax)
-            {
-              bestScore = currentMax; bestCol = j; bestRow = readLength - 1 - i;
-            }
+          // Update best score observed till now
+          if (bestScore == currentMax) {
+            bestScore = currentMax;
+            bestCol = j;
+            bestRow = readLength - 1 - i;
+          }
 
-            //special handling of the cell where optimal alignment had ended during forward DP
-            if (j == bestScoreVector[readno].refColumnEnd && (readLength - 1 - i) == bestScoreVector[readno].qryRowEnd)
-            {
-              //local alignment needs to end with a match
-              assert (currentMax == parameters.match);
+          // special handling of the cell where optimal alignment had ended
+          // during forward DP
+          if (j == bestScoreVector[readno].refColumnEnd &&
+              (readLength - 1 - i) == bestScoreVector[readno].qryRowEnd) {
+            // local alignment needs to end with a match
+            assert(currentMax == parameters.match);
 
-              //add one so that the other end of the optimal alignment can be located without ambuiguity
-              matrix[i & 1][j] = parameters.match + 1;
-            }
-          } // end of row computation
-        } // end of DP
+            // add one so that the other end of the optimal alignment can be
+            // located without ambuiguity
+            matrix[i & 1][j] = parameters.match + 1;
+          }
+        } // end of row computation
+      }   // end of DP
 
-        assert (bestScoreVector[readno].score == bestScore - 1);    //offset by 1
-        bestScoreVector[readno].refColumnStart = bestCol;
-        bestScoreVector[readno].qryRowStart = bestRow;
+      assert(bestScoreVector[readno].score == bestScore - 1); // offset by 1
+      bestScoreVector[readno].refColumnStart = bestCol;
+      bestScoreVector[readno].qryRowStart = bestRow;
 
-      } // all reads done
-    } //end of omp parallel
+    } // all reads done
+  }   // end of omp parallel
 
-    auto tick2 = __rdtsc();
+  // auto tick2 = __rdtsc();
 
-    std::cout << "TIMER, psgl::alignToDAGLocal_Phase1_rev_scalar, CPU cycles spent in phase 1-R = " << tick2 - tick1 
-      << ", estimated time (s) = " << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << "\n";
+  // std::cout << "TIMER, psgl::alignToDAGLocal_Phase1_rev_scalar, CPU cycles "
+  //              "spent in phase 1-R = "
+  //           << tick2 - tick1 << ", estimated time (s) = "
+  //           << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << "\n";
 
 #ifdef VTUNE_SUPPORT
-    __itt_pause();
+  __itt_pause();
 #endif
+}
 
-  }
-
-  /**
-   * @brief                         execute second phase of alignment i.e. compute cigar
-   * @param[in]   readSet
-   * @param[in]   graph
-   * @param[in]   parameters        input parameters
-   * @param[in]   bestScoreVector   best score and alignment location for each read
-   * @note                          we assume that query sequences are oriented properly
-   *                                after executing the alignment phase 1
-   */
-  void alignToDAGLocal_Phase2(  const std::vector<std::string> &readSet,
-                                const CSR_char_container &graph,
-                                const Parameters &parameters, 
-                                std::vector< BestScoreInfo > &bestScoreVector)
-  {
-    assert (bestScoreVector.size() == readSet.size());
+/**
+ * @brief                         execute second phase of alignment i.e. compute
+ * cigar
+ * @param[in]   readSet
+ * @param[in]   graph
+ * @param[in]   parameters        input parameters
+ * @param[in]   bestScoreVector   best score and alignment location for each
+ * read
+ * @note                          we assume that query sequences are oriented
+ * properly after executing the alignment phase 1
+ */
+inline void alignToDAGLocal_Phase2(const std::vector<std::string> &readSet,
+                            const CSR_char_container &graph,
+                            const Parameters &parameters,
+                            std::vector<BestScoreInfo> &bestScoreVector) {
+  assert(bestScoreVector.size() == readSet.size());
 
-    std::vector<double> threadTimings (parameters.threads, 0);
+  std::vector<double> threadTimings(parameters.threads, 0);
 
-#pragma omp parallel  
-    {
-      threadTimings[omp_get_thread_num()] = omp_get_wtime();
+#pragma omp parallel num_threads(parameters.threads)
+  {
+    threadTimings[omp_get_thread_num()] = omp_get_wtime();
 
 #pragma omp for schedule(dynamic) nowait
-      for (size_t readno = 0; readno < readSet.size(); readno++)
-      {
-        //for time profiling within phase 2
-        uint64_t time_p2_1, time_p2_2;
+    for (size_t readno = 0; readno < readSet.size(); readno++) {
+      // for time profiling within phase 2
+      // uint64_t time_p2_1, time_p2_2;
 
-        //read length
-        auto readLength = readSet[readno].length();
+      // read length
+      // auto readLength = readSet[readno].length();
 
-        //
-        // PHASE 2.1 : RECOMPUTE DP MATRIX WITH TRACEBACK INFORMATION
-        // recomputation is done within selected block of DP matrix
-        //
+      //
+      // PHASE 2.1 : RECOMPUTE DP MATRIX WITH TRACEBACK INFORMATION
+      // recomputation is done within selected block of DP matrix
+      //
 
-        //width of score matrix that we need in memory
-        std::size_t reducedWidth = bestScoreVector[readno].refColumnEnd - bestScoreVector[readno].refColumnStart + 1;
+      // width of score matrix that we need in memory
+      std::size_t reducedWidth = bestScoreVector[readno].refColumnEnd -
+                                 bestScoreVector[readno].refColumnStart + 1;
 
-        //for new beginning column
-        std::size_t j0 = bestScoreVector[readno].refColumnStart; 
+      // for new beginning column
+      std::size_t j0 = bestScoreVector[readno].refColumnStart;
 
-        //height of scoring matrix for re-computation
-        std::size_t reducedHeight = bestScoreVector[readno].qryRowEnd - bestScoreVector[readno].qryRowStart + 1; 
+      // height of scoring matrix for re-computation
+      std::size_t reducedHeight = bestScoreVector[readno].qryRowEnd -
+                                  bestScoreVector[readno].qryRowStart + 1;
 
-        //for new beginning row
-        std::size_t i0 = bestScoreVector[readno].qryRowStart; 
+      // for new beginning row
+      std::size_t i0 = bestScoreVector[readno].qryRowStart;
 
-        //scores in the last row
-        std::vector<int32_t> finalRow(reducedWidth, 0);
+      // scores in the last row
+      std::vector<int32_t> finalRow(reducedWidth, 0);
 
-        //complete score matrix of size height x width to allow traceback
-        //Note: to optimize storge, we only store vertical difference; absolute values of 
-        //      which is bounded by gap penalty
+      // complete score matrix of size height x width to allow traceback
+      // Note: to optimize storge, we only store vertical difference; absolute
+      // values of
+      //       which is bounded by gap penalty
 #ifdef DEBUG
-        std::cout << "INFO, psgl::alignToDAGLocal_Phase2, aligning read #" << readno + 1 << ", memory requested= " << reducedWidth * reducedHeight << " bytes" << std::endl;
+      std::cout << "INFO, psgl::alignToDAGLocal_Phase2, aligning read #"
+                << readno + 1
+                << ", memory requested= " << reducedWidth * reducedHeight
+                << " bytes" << std::endl;
 #endif
 
-        std::vector< std::vector<int8_t> > completeMatrixLog(reducedHeight, std::vector<int8_t>(reducedWidth, 0));
+      std::vector<std::vector<int8_t>> completeMatrixLog(
+          reducedHeight, std::vector<int8_t>(reducedWidth, 0));
+
+      {
+        // auto tick1 = __rdtsc();
+
+        // scoring matrix of size 2 x width, init with zero
+        std::vector<std::vector<int32_t>> matrix(
+            2, std::vector<int32_t>(reducedWidth, 0));
+
+        // iterate over characters in read
+        for (std::size_t i = 0; i < reducedHeight; i++) {
+          // iterate over characters in reference graph
+          for (std::size_t j = 0; j < reducedWidth; j++) {
+            // current reference character
+            char curChar = graph.vertex_label[j + j0];
+
+            // insertion edit
+            int32_t fromInsertion = matrix[(i - 1) & 1][j] - parameters.ins;
+            //'& 1' is same as doing modulo 2
+
+            // match-mismatch edit
+            int32_t matchScore = curChar == readSet[readno][i + i0]
+                                     ? parameters.match
+                                     : -1 * parameters.mismatch;
+            int32_t fromMatch =
+                matchScore; // also handles the case when in-degree is zero
+
+            // deletion edit
+            int32_t fromDeletion = -1;
+
+            for (auto k = graph.offsets_in[j + j0];
+                 k < graph.offsets_in[j + j0 + 1]; k++) {
+              // ignore edges outside the range
+              if (graph.adjcny_in[k] >= j0) {
+                fromMatch = psgl_max(
+                    fromMatch,
+                    matrix[(i - 1) & 1][graph.adjcny_in[k] - j0] + matchScore);
+                fromDeletion = psgl_max(fromDeletion,
+                                        matrix[i & 1][graph.adjcny_in[k] - j0] -
+                                            parameters.del);
+              }
+            }
 
-        {
-          auto tick1 = __rdtsc();
+            // evaluate current score
+            matrix[i & 1][j] = psgl_max(psgl_max(fromInsertion, fromMatch),
+                                        psgl_max(fromDeletion, 0));
 
-          //scoring matrix of size 2 x width, init with zero
-          std::vector< std::vector<int32_t> > matrix(2, std::vector<int32_t>(reducedWidth, 0));
+            // save vertical difference of scores, used later for backtracking
+            completeMatrixLog[i][j] = matrix[i & 1][j] - matrix[(i - 1) & 1][j];
+          }
 
-          //iterate over characters in read
-          for (std::size_t i = 0; i < reducedHeight; i++)
-          {
-            //iterate over characters in reference graph
-            for (std::size_t j = 0; j < reducedWidth; j++)
-            {
-              //current reference character
-              char curChar = graph.vertex_label[j + j0];
-
-              //insertion edit
-              int32_t fromInsertion = matrix[(i-1) & 1][j] - parameters.ins;
-              //'& 1' is same as doing modulo 2
-
-              //match-mismatch edit
-              int32_t matchScore = curChar == readSet[readno][i + i0] ? parameters.match : -1 * parameters.mismatch;
-              int32_t fromMatch = matchScore;   //also handles the case when in-degree is zero 
-
-              //deletion edit
-              int32_t fromDeletion  = -1; 
-
-              for(auto k = graph.offsets_in[j + j0]; k < graph.offsets_in[j + j0 + 1]; k++)
-              {
-                //ignore edges outside the range 
-                if ( graph.adjcny_in[k] >= j0)
-                {
-                  fromMatch = psgl_max (fromMatch, matrix[(i-1) & 1][ graph.adjcny_in[k] - j0] + matchScore);
-                  fromDeletion = psgl_max (fromDeletion, matrix[i & 1][ graph.adjcny_in[k] - j0] - parameters.del);
-                }
-              }
+          // Save last row
+          if (i == reducedHeight - 1)
+            finalRow = matrix[i & 1];
+        }
 
-              //evaluate current score
-              matrix[i & 1][j] = psgl_max ( psgl_max(fromInsertion, fromMatch) , psgl_max(fromDeletion, 0) );
+        int32_t bestScoreReComputed =
+            *std::max_element(finalRow.begin(), finalRow.end());
 
-              //save vertical difference of scores, used later for backtracking
-              completeMatrixLog[i][j] = matrix[i & 1][j] - matrix[(i-1) & 1][j];
-            }
+        // the recomputed score and its location should match our original
+        // calculation
+        assert(bestScoreReComputed == bestScoreVector[readno].score);
+        assert(bestScoreReComputed ==
+               finalRow[bestScoreVector[readno].refColumnEnd - j0]);
 
-            //Save last row
-            if (i == reducedHeight - 1) 
-              finalRow = matrix[i & 1];
-          }
+        // auto tick2 = __rdtsc();
+        // time_p2_1 = tick2 - tick1;
+      }
 
-          int32_t bestScoreReComputed = *std::max_element(finalRow.begin(), finalRow.end());
+      //
+      // PHASE 2.2 : COMPUTE CIGAR
+      //
 
-          //the recomputed score and its location should match our original calculation
-          assert( bestScoreReComputed == bestScoreVector[readno].score );
-          assert( bestScoreReComputed == finalRow[ bestScoreVector[readno].refColumnEnd - j0 ] );
+      std::string cigar;
+      std::vector<int32_t> used_cols;
 
-          auto tick2 = __rdtsc();
-          time_p2_1 = tick2 - tick1;
-        }
+      {
+        // auto tick1 = __rdtsc();
 
-        //
-        // PHASE 2.2 : COMPUTE CIGAR
-        //
+        std::vector<int32_t> currentRowScores = finalRow;
+        std::vector<int32_t> aboveRowScores(reducedWidth);
 
-        std::string cigar;
-        std::vector<int32_t> used_cols;
+        int col = reducedWidth - 1;
+        int row = reducedHeight - 1;
 
-        {
-          auto tick1 = __rdtsc();
+        while (col >= 0 && row >= 0) {
+          used_cols.push_back(col + j0); // CHECKME
+          if (currentRowScores[col] <= 0)
+            break;
 
-          std::vector<int32_t> currentRowScores = finalRow; 
-          std::vector<int32_t> aboveRowScores (reducedWidth);
+          // retrieve score values from vertical score differences
+          for (std::size_t i = 0; i < reducedWidth; i++)
+            aboveRowScores[i] = currentRowScores[i] - completeMatrixLog[row][i];
 
-          int col = reducedWidth - 1;
-          int row = reducedHeight - 1;
+          // current reference character
+          char curChar = graph.vertex_label[col + j0];
 
-          while (col >= 0 && row >= 0)
-          {
-            used_cols.push_back(col + j0); // CHECKME
-            if (currentRowScores[col] <= 0)
-              break;
-
-            //retrieve score values from vertical score differences
-            for(std::size_t i = 0; i < reducedWidth; i++)
-              aboveRowScores[i] = currentRowScores[i] - completeMatrixLog[row][i]; 
-
-            //current reference character
-            char curChar = graph.vertex_label[col + j0];
-
-            //insertion edit
-            int32_t fromInsertion = aboveRowScores[col] - parameters.ins;
-
-            //match-mismatch edit
-            int32_t matchScore = curChar == readSet[readno][row + i0] ? parameters.match : -1 * parameters.mismatch;
-
-            int32_t fromMatch = matchScore;   //also handles the case when in-degree is zero 
-            std::size_t fromMatchPos = col;
-
-            //deletion edit
-            int32_t fromDeletion = -1; 
-            std::size_t fromDeletionPos;
-
-            for(auto k = graph.offsets_in[col + j0]; k < graph.offsets_in[col + j0 + 1]; k++)
-            {
-              if ( graph.adjcny_in[k] >= j0)
-              {
-                auto fromCol = graph.adjcny_in[k] - j0;
-
-                if (fromMatch < aboveRowScores[fromCol] + matchScore)
-                {
-                  fromMatch = aboveRowScores[fromCol] + matchScore;
-                  fromMatchPos = fromCol;
-                }
-
-                if (fromDeletion < currentRowScores[fromCol] - parameters.del)
-                {
-                  fromDeletion = currentRowScores[fromCol] - parameters.del;
-                  fromDeletionPos = fromCol;
-                }
-              }
-            }
+          // insertion edit
+          int32_t fromInsertion = aboveRowScores[col] - parameters.ins;
 
-            //evaluate recurrence
-            {
-              if (currentRowScores[col] == fromMatch)
-              {
-                if (matchScore == parameters.match)
-                  cigar.push_back('=');
-                else
-                  cigar.push_back('X');
+          // match-mismatch edit
+          int32_t matchScore = curChar == readSet[readno][row + i0]
+                                   ? parameters.match
+                                   : -1 * parameters.mismatch;
 
-                //if alignment starts from this column, stop
-                if (fromMatchPos == col)
-                  break;
+          int32_t fromMatch =
+              matchScore; // also handles the case when in-degree is zero
+          std::size_t fromMatchPos = col;
 
-                //shift to preceeding column
-                col = fromMatchPos;
+          // deletion edit
+          int32_t fromDeletion = -1;
+          std::size_t fromDeletionPos;
 
-                //shift to above row
-                row--; currentRowScores = aboveRowScores;
-              }
-              else if (currentRowScores[col] == fromDeletion)
-              {
-                cigar.push_back('D');
+          for (auto k = graph.offsets_in[col + j0];
+               k < graph.offsets_in[col + j0 + 1]; k++) {
+            if (graph.adjcny_in[k] >= j0) {
+              auto fromCol = graph.adjcny_in[k] - j0;
 
-                //shift to preceeding column
-                col = fromDeletionPos;
+              if (fromMatch < aboveRowScores[fromCol] + matchScore) {
+                fromMatch = aboveRowScores[fromCol] + matchScore;
+                fromMatchPos = fromCol;
               }
-              else 
-              {
-                assert(currentRowScores[col] == fromInsertion);
-
-                cigar.push_back('I');
 
-                //shift to above row
-                row--; currentRowScores = aboveRowScores;
+              if (fromDeletion < currentRowScores[fromCol] - parameters.del) {
+                fromDeletion = currentRowScores[fromCol] - parameters.del;
+                fromDeletionPos = fromCol;
               }
             }
           }
 
-          //string reverse 
-          std::reverse (cigar.begin(), cigar.end());  
+          // evaluate recurrence
+          {
+            if (currentRowScores[col] == fromMatch) {
+              if (matchScore == parameters.match)
+                cigar.push_back('=');
+              else
+                cigar.push_back('X');
+
+              // if alignment starts from this column, stop
+              if (fromMatchPos == col)
+                break;
+
+              // shift to preceeding column
+              col = fromMatchPos;
+
+              // shift to above row
+              row--;
+              currentRowScores = aboveRowScores;
+            } else if (currentRowScores[col] == fromDeletion) {
+              cigar.push_back('D');
+
+              // shift to preceeding column
+              col = fromDeletionPos;
+            } else {
+              assert(currentRowScores[col] == fromInsertion);
+
+              cigar.push_back('I');
+
+              // shift to above row
+              row--;
+              currentRowScores = aboveRowScores;
+            }
+          }
+        }
 
-          //shorten the cigar string
-          psgl::seqUtils::cigarCompact(cigar);
+        // string reverse
+        std::reverse(cigar.begin(), cigar.end());
 
-          //validate if cigar yields best score
-          assert ( psgl::seqUtils::cigarScore (cigar, parameters) ==  bestScoreVector[readno].score );
+        // shorten the cigar string
+        psgl::seqUtils::cigarCompact(cigar);
 
-          bestScoreVector[readno].cigar = cigar;
-          std::reverse(used_cols.begin(), used_cols.end());
-          bestScoreVector[readno].refColumns = used_cols;
-          auto tick2 = __rdtsc();
-          time_p2_2 = tick2 - tick1;
-        }
+        // validate if cigar yields best score
+        assert(psgl::seqUtils::cigarScore(cigar, parameters) ==
+               bestScoreVector[readno].score);
 
-#ifdef DEBUG
-        std::cout << "INFO, psgl::alignToDAGLocal_Phase2, aligning read #" << readno + 1 << ", len = " << readLength << ", score " << bestScoreVector[readno].score << ", strand " << bestScoreVector[readno].strand << "\n";
-        std::cout << "INFO, psgl::alignToDAGLocal_Phase2, cigar: " << bestScoreVector[readno].cigar << "\n";
-        std::cout << "TIMER, psgl::alignToDAGLocal_Phase2, CPU cycles spent in :  phase 2.1 = " << time_p2_1 * 1.0 / ASSUMED_CPU_FREQ << ", phase 2.2 = " << time_p2_2 * 1.0 / ASSUMED_CPU_FREQ << "\n";
-        //std::cout.flush();
-#endif
+        bestScoreVector[readno].cigar = cigar;
+        std::reverse(used_cols.begin(), used_cols.end());
+        bestScoreVector[readno].refColumns = used_cols;
+        // auto tick2 = __rdtsc();
+        // time_p2_2 = tick2 - tick1;
       }
 
-      threadTimings[omp_get_thread_num()] = omp_get_wtime() - threadTimings[omp_get_thread_num()];
-
+#ifdef DEBUG
+      std::cout << "INFO, psgl::alignToDAGLocal_Phase2, aligning read #"
+                << readno + 1 << ", len = " << readLength << ", score "
+                << bestScoreVector[readno].score << ", strand "
+                << bestScoreVector[readno].strand << "\n";
+      std::cout << "INFO, psgl::alignToDAGLocal_Phase2, cigar: "
+                << bestScoreVector[readno].cigar << "\n";
+      std::cout << "TIMER, psgl::alignToDAGLocal_Phase2, CPU cycles spent in : "
+                   " phase 2.1 = "
+                << time_p2_1 * 1.0 / ASSUMED_CPU_FREQ
+                << ", phase 2.2 = " << time_p2_2 * 1.0 / ASSUMED_CPU_FREQ
+                << "\n";
+      // std::cout.flush();
+#endif
     }
 
-    std::cout << "TIMER, psgl::alignToDAGLocal_Phase2, individual thread timings (s) : " << printStats(threadTimings) << "\n"; 
+    threadTimings[omp_get_thread_num()] =
+        omp_get_wtime() - threadTimings[omp_get_thread_num()];
   }
 
-  /**
-   * @brief                               local alignment routine
-   * @param[in]   readSet
-   * @param[in]   graph                   node-labeled directed graph 
-   * @param[in]   parameters              input parameters
-   * @param[out]  outputBestScoreVector
-   */
-  void alignToDAGLocal( const std::vector<std::string> &readSet,
-      const CSR_char_container &graph,
-      const Parameters &parameters, 
-      std::vector< BestScoreInfo > &outputBestScoreVector)
-  {
-    //create buffer to save best score info for each read and its rev. complement
-    std::vector< BestScoreInfo > bestScoreVector_P1 (2 * readSet.size() );
-
-    //to save input query sequences for phase 1
-    std::vector<std::string> readSet_P1;
-
-    assert (readSet.size() > 0);
-    assert (outputBestScoreVector.empty());
-
-
+  // std::cout
+  //     << "TIMER, psgl::alignToDAGLocal_Phase2, individual thread timings (s) : "
+  //     << printStats(threadTimings) << "\n";
+}
 
-    //
-    // Phase 1 [get best score values and locations]
-    //
-    {
-      auto tick1 = __rdtsc();
+/**
+ * @brief                               local alignment routine
+ * @param[in]   readSet
+ * @param[in]   graph                   node-labeled directed graph
+ * @param[in]   parameters              input parameters
+ * @param[out]  outputBestScoreVector
+ */
+inline void alignToDAGLocal(const std::vector<std::string> &readSet,
+                     const CSR_char_container &graph,
+                     const Parameters &parameters,
+                     std::vector<BestScoreInfo> &outputBestScoreVector) {
+  // create buffer to save best score info for each read and its rev. complement
+  std::vector<BestScoreInfo> bestScoreVector_P1(2 * readSet.size());
+
+  // to save input query sequences for phase 1
+  std::vector<std::string> readSet_P1;
+
+  assert(readSet.size() > 0);
+  assert(outputBestScoreVector.empty());
+
+  //
+  // Phase 1 [get best score values and locations]
+  //
+  {
+    // auto tick1 = __rdtsc();
 
-      size_t maxReadLength = 0;
+    size_t maxReadLength = 0;
 
-      for (size_t readno = 0; readno < readSet.size(); readno++)
-      {
-        std::string read_reverse (readSet[readno]);
-        psgl::seqUtils::reverseComplement( readSet[readno], read_reverse); 
+    for (size_t readno = 0; readno < readSet.size(); readno++) {
+      std::string read_reverse(readSet[readno]);
+      psgl::seqUtils::reverseComplement(readSet[readno], read_reverse);
 
-        readSet_P1.push_back (readSet[readno]);
-        readSet_P1.push_back (readSet[readno]);
-        // readSet_P1.push_back (read_reverse);
+      readSet_P1.push_back(readSet[readno]);
+      readSet_P1.push_back(readSet[readno]);
+      // readSet_P1.push_back (read_reverse);
 
-        if (readSet[readno].length() > maxReadLength)
-          maxReadLength = readSet[readno].length();
-      }
+      if (readSet[readno].length() > maxReadLength)
+        maxReadLength = readSet[readno].length();
+    }
 
-      assert (bestScoreVector_P1.size() == 2 * readSet.size() );
-      assert (readSet_P1.size() == 2 * readSet.size() );
+    assert(bestScoreVector_P1.size() == 2 * readSet.size());
+    assert(readSet_P1.size() == 2 * readSet.size());
 
-      //align read to ref.
+    // align read to ref.
 #if defined(PASGAL_ENABLE_AVX512) || defined(PASGAL_ENABLE_AVX2)
 
-      //there would be few padded characters at the end of qry seq
-      //take that into account when computing max. read length
-      auto blockHeight = Phase1_Vectorized< SimdInst<int8_t> >::blockHeight;
-      maxReadLength += blockHeight - 1 - (maxReadLength - 1) % blockHeight; 
-
-      //decide precision by looking at maximum score possible
-      if (maxReadLength * parameters.match <= INT8_MAX) 
-      {
-        Phase1_Vectorized< SimdInst<int8_t> > obj (readSet_P1, graph, parameters); 
-        obj.alignToDAGLocal_Phase1_vectorized_wrapper(bestScoreVector_P1);
-      }
-      else if (maxReadLength * parameters.match <= INT16_MAX) 
-      {
-        Phase1_Vectorized< SimdInst<int16_t> > obj (readSet_P1, graph, parameters); 
-        obj.alignToDAGLocal_Phase1_vectorized_wrapper(bestScoreVector_P1);
-      }
-      else 
-      {
-        Phase1_Vectorized< SimdInst<int32_t> > obj (readSet_P1, graph, parameters); 
-        obj.alignToDAGLocal_Phase1_vectorized_wrapper(bestScoreVector_P1);
-      }
+    // there would be few padded characters at the end of qry seq
+    // take that into account when computing max. read length
+    auto blockHeight = Phase1_Vectorized<SimdInst<int8_t>>::blockHeight;
+    maxReadLength += blockHeight - 1 - (maxReadLength - 1) % blockHeight;
+
+    // decide precision by looking at maximum score possible
+    if (maxReadLength * parameters.match <= INT8_MAX) {
+      Phase1_Vectorized<SimdInst<int8_t>> obj(readSet_P1, graph, parameters);
+      obj.alignToDAGLocal_Phase1_vectorized_wrapper(bestScoreVector_P1);
+    } else if (maxReadLength * parameters.match <= INT16_MAX) {
+      Phase1_Vectorized<SimdInst<int16_t>> obj(readSet_P1, graph, parameters);
+      obj.alignToDAGLocal_Phase1_vectorized_wrapper(bestScoreVector_P1);
+    } else {
+      Phase1_Vectorized<SimdInst<int32_t>> obj(readSet_P1, graph, parameters);
+      obj.alignToDAGLocal_Phase1_vectorized_wrapper(bestScoreVector_P1);
+    }
 #else
-      alignToDAGLocal_Phase1_scalar (readSet_P1, graph, parameters, bestScoreVector_P1);
+    alignToDAGLocal_Phase1_scalar(readSet_P1, graph, parameters,
+                                  bestScoreVector_P1);
 #endif
 
-      auto tick2 = __rdtsc();
-      std::cout << "TIMER, psgl::alignToDAG, CPU cycles spent in phase 1  = " << tick2 - tick1
-        << ", estimated time (s) = " << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << std::endl;
-    }
+    // auto tick2 = __rdtsc();
+    // std::cout << "TIMER, psgl::alignToDAG, CPU cycles spent in phase 1  = "
+    //           << tick2 - tick1 << ", estimated time (s) = "
+    //           << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << std::endl;
+  }
 
 #ifdef DEBUG
-    {
-      for (size_t readno = 0; readno < readSet_P1.size(); readno++)
-      {
-        std::cout << "INFO, psgl::alignToDAGLocal, read # " << readno + 1 << ", score = " << bestScoreVector_P1[readno].score 
-          << ", refColumnEnd = " << bestScoreVector_P1[readno].refColumnEnd
-          << ", qryRowEnd = " << bestScoreVector_P1[readno].qryRowEnd << "\n";
-      }
+  {
+    for (size_t readno = 0; readno < readSet_P1.size(); readno++) {
+      std::cout << "INFO, psgl::alignToDAGLocal, read # " << readno + 1
+                << ", score = " << bestScoreVector_P1[readno].score
+                << ", refColumnEnd = "
+                << bestScoreVector_P1[readno].refColumnEnd
+                << ", qryRowEnd = " << bestScoreVector_P1[readno].qryRowEnd
+                << "\n";
     }
+  }
 #endif
 
-    //
-    // Phase 1 - reverse [get begin locations]
-    //
-    {
-      auto tick1 = __rdtsc();
+  //
+  // Phase 1 - reverse [get begin locations]
+  //
+  {
+    // auto tick1 = __rdtsc();
 
-      std::vector<std::string> readSet_P1_R;
+    std::vector<std::string> readSet_P1_R;
 
-      size_t maxReadLength = 0;
+    size_t maxReadLength = 0;
 
-      for (size_t readno = 0; readno < readSet.size(); readno++)
-      {
-        if (bestScoreVector_P1[2 * readno].score > bestScoreVector_P1[2 * readno + 1].score)
-        {
-          outputBestScoreVector.push_back (bestScoreVector_P1[2 * readno]);
-          outputBestScoreVector[readno].strand = '+';
-
-          std::string read_reverse (readSet_P1[2 * readno]);
-          psgl::seqUtils::reverse( readSet_P1[2 * readno], read_reverse); 
-          readSet_P1_R.push_back (read_reverse);
-        }
-        else
-        {
-          outputBestScoreVector.push_back (bestScoreVector_P1[2 * readno + 1]);
-          outputBestScoreVector[readno].strand = '+';
-
-          std::string read_reverse (readSet_P1[2 * readno + 1]);
-          psgl::seqUtils::reverse( readSet_P1[2 * readno + 1], read_reverse); 
-          readSet_P1_R.push_back (read_reverse);
-        }
+    for (size_t readno = 0; readno < readSet.size(); readno++) {
+      if (bestScoreVector_P1[2 * readno].score >
+          bestScoreVector_P1[2 * readno + 1].score) {
+        outputBestScoreVector.push_back(bestScoreVector_P1[2 * readno]);
+        outputBestScoreVector[readno].strand = '+';
 
-        outputBestScoreVector[readno].qryId = readno;
+        std::string read_reverse(readSet_P1[2 * readno]);
+        psgl::seqUtils::reverse(readSet_P1[2 * readno], read_reverse);
+        readSet_P1_R.push_back(read_reverse);
+      } else {
+        outputBestScoreVector.push_back(bestScoreVector_P1[2 * readno + 1]);
+        outputBestScoreVector[readno].strand = '+';
 
-        if (readSet[readno].length() > maxReadLength)
-          maxReadLength = readSet[readno].length();
+        std::string read_reverse(readSet_P1[2 * readno + 1]);
+        psgl::seqUtils::reverse(readSet_P1[2 * readno + 1], read_reverse);
+        readSet_P1_R.push_back(read_reverse);
       }
 
-      assert (outputBestScoreVector.size() == readSet.size() );
-      assert (readSet_P1_R.size() == readSet.size() );
+      outputBestScoreVector[readno].qryId = readno;
 
-      //align reverse read to ref.
-#if defined(PASGAL_ENABLE_AVX512) || defined(PASGAL_ENABLE_AVX2)
+      if (readSet[readno].length() > maxReadLength)
+        maxReadLength = readSet[readno].length();
+    }
 
-      //there would be few padded characters at the end of qry seq
-      //take that into account when computing max. read length
-      auto blockHeight = Phase1_Rev_Vectorized< SimdInst<int8_t> >::blockHeight;
-      maxReadLength += blockHeight - 1 - (maxReadLength - 1) % blockHeight; 
+    assert(outputBestScoreVector.size() == readSet.size());
+    assert(readSet_P1_R.size() == readSet.size());
 
-      //decide precision by looking at maximum score possible
-      //offset by 1 because we augment the score by 1 during rev. DP
-      if (maxReadLength * parameters.match <= INT8_MAX - 1) 
-      {
-        Phase1_Rev_Vectorized< SimdInst<int8_t> > obj (readSet_P1_R, graph, parameters); 
-        obj.alignToDAGLocal_Phase1_rev_vectorized_wrapper(outputBestScoreVector);
-      }
-      else if (maxReadLength * parameters.match <= INT16_MAX - 1) 
-      {
-        Phase1_Rev_Vectorized< SimdInst<int16_t> > obj (readSet_P1_R, graph, parameters); 
-        obj.alignToDAGLocal_Phase1_rev_vectorized_wrapper(outputBestScoreVector);
-      }
-      else 
-      {
-        Phase1_Rev_Vectorized< SimdInst<int32_t> > obj (readSet_P1_R, graph, parameters); 
-        obj.alignToDAGLocal_Phase1_rev_vectorized_wrapper(outputBestScoreVector);
-      }
+    // align reverse read to ref.
+#if defined(PASGAL_ENABLE_AVX512) || defined(PASGAL_ENABLE_AVX2)
+
+    // there would be few padded characters at the end of qry seq
+    // take that into account when computing max. read length
+    auto blockHeight = Phase1_Rev_Vectorized<SimdInst<int8_t>>::blockHeight;
+    maxReadLength += blockHeight - 1 - (maxReadLength - 1) % blockHeight;
+
+    // decide precision by looking at maximum score possible
+    // offset by 1 because we augment the score by 1 during rev. DP
+    if (maxReadLength * parameters.match <= INT8_MAX - 1) {
+      Phase1_Rev_Vectorized<SimdInst<int8_t>> obj(readSet_P1_R, graph,
+                                                  parameters);
+      obj.alignToDAGLocal_Phase1_rev_vectorized_wrapper(outputBestScoreVector);
+    } else if (maxReadLength * parameters.match <= INT16_MAX - 1) {
+      Phase1_Rev_Vectorized<SimdInst<int16_t>> obj(readSet_P1_R, graph,
+                                                   parameters);
+      obj.alignToDAGLocal_Phase1_rev_vectorized_wrapper(outputBestScoreVector);
+    } else {
+      Phase1_Rev_Vectorized<SimdInst<int32_t>> obj(readSet_P1_R, graph,
+                                                   parameters);
+      obj.alignToDAGLocal_Phase1_rev_vectorized_wrapper(outputBestScoreVector);
+    }
 #else
-      alignToDAGLocal_Phase1_rev_scalar (readSet_P1_R, graph, parameters, outputBestScoreVector);
+    alignToDAGLocal_Phase1_rev_scalar(readSet_P1_R, graph, parameters,
+                                      outputBestScoreVector);
 #endif
 
-      auto tick2 = __rdtsc();
-      std::cout << "TIMER, psgl::alignToDAG, CPU cycles spent in phase 1-R  = " << tick2 - tick1
-        << ", estimated time (s) = " << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << std::endl;
-    }
+    // auto tick2 = __rdtsc();
+    // std::cout << "TIMER, psgl::alignToDAG, CPU cycles spent in phase 1-R  = "
+    //           << tick2 - tick1 << ", estimated time (s) = "
+    //           << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << std::endl;
+  }
 
 #ifdef DEBUG
-    {
-      for (size_t readno = 0; readno < readSet.size(); readno++)
-      {
-        std::cout << "INFO, psgl::alignToDAGLocal, read # " << readno + 1 << ", score = " << outputBestScoreVector[readno].score 
-          << ", refColumnStart = " << outputBestScoreVector[readno].refColumnStart 
-          << ", refColumnEnd = " << outputBestScoreVector[readno].refColumnEnd
-          << ", qryRowStart = " << outputBestScoreVector[readno].qryRowStart
-          << ", qryRowEnd = " << outputBestScoreVector[readno].qryRowEnd << "\n";
-      }
+  {
+    for (size_t readno = 0; readno < readSet.size(); readno++) {
+      std::cout << "INFO, psgl::alignToDAGLocal, read # " << readno + 1
+                << ", score = " << outputBestScoreVector[readno].score
+                << ", refColumnStart = "
+                << outputBestScoreVector[readno].refColumnStart
+                << ", refColumnEnd = "
+                << outputBestScoreVector[readno].refColumnEnd
+                << ", qryRowStart = "
+                << outputBestScoreVector[readno].qryRowStart
+                << ", qryRowEnd = " << outputBestScoreVector[readno].qryRowEnd
+                << "\n";
     }
+  }
 #endif
 
-    //
-    // Phase 2 [comute cigar]
-    //
-    {
-      auto tick1 = __rdtsc();
-
-      std::vector<std::string> readSet_P2;
-
-      for (size_t readno = 0; readno < readSet.size(); readno++)
-      {
-        if (bestScoreVector_P1[2 * readno].score > bestScoreVector_P1[2 * readno + 1].score)
-          readSet_P2.push_back (readSet_P1[2 * readno]);
-        else
-          readSet_P2.push_back (readSet_P1[2 * readno + 1]);
-      }
-
-      assert (readSet_P2.size() == readSet.size() );
-
-      alignToDAGLocal_Phase2 (readSet_P2, graph, parameters, outputBestScoreVector);
-
-      auto tick2 = __rdtsc();
-      std::cout << "TIMER, psgl::alignToDAG, CPU cycles spent in phase 2  = " << tick2 - tick1
-        << ", estimated time (s) = " << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << "\n";
-    }
-  }
+  //
+  // Phase 2 [comute cigar]
+  //
+  {
+    // auto tick1 = __rdtsc();
 
-  /**
-   * @brief                                 alignment routine
-   * @param[in]   reads                     vector of strings
-   * @param[in]   graph
-   * @param[in]   parameters                input parameters
-   * @param[in]   mode                      alignment mode
-   * @param[out]  outputBestScoreVector
-   */
-    void alignToDAG(  const std::vector<std::string> &reads, 
-                      const CSR_char_container &graph,
-                      const Parameters &parameters, 
-                      const MODE mode,
-                      std::vector< BestScoreInfo > &outputBestScoreVector)
-    {
-      //TODO: Support other alignment modes: global and semi-global
-      switch(mode)
-      {
-        case LOCAL : alignToDAGLocal (reads, graph, parameters, outputBestScoreVector); break;
-        default: std::cerr << "ERROR, psgl::alignToDAG, Invalid alignment mode"; exit(1);
-      }
-    }
+    std::vector<std::string> readSet_P2;
 
-    /**
-     * @brief                                 print alignment results to file
-     * @param[in]   parameters                input parameters
-     * @param[in]   graph
-     * @param[in]   outputBestScoreVector
-     */
-    void printResultsToFile ( const Parameters &parameters,
-        const std::vector<ContigInfo> &qmetadata,
-        const CSR_char_container &graph,
-        const std::vector< BestScoreInfo > &outputBestScoreVector)
-    {
-      std::ofstream outstrm(parameters.ofile);
-
-      assert(qmetadata.size() == outputBestScoreVector.size());
-
-      for(auto &e : outputBestScoreVector)
-      {
-        std::vector<uint> path;
-        std::string path_str = "";
-        path.push_back(graph.originalVertexId[e.refColumnStart].first);
-        path_str += std::to_string(path.back());
-        for(const int32_t c : e.refColumns) {
-          if (c >= e.refColumnStart && c <= e.refColumnEnd) {
-            int32_t n = graph.originalVertexId[c].first;
-            if (n != path.back()) {
-              path.push_back(n);
-              path_str += "-" + std::to_string(path.back());
-            }
-          }
-        }
-        outstrm << qmetadata[e.qryId].name << "\t" 
-          << qmetadata[e.qryId].len << "\t"
-          << e.qryRowStart << "\t" 
-          << e.qryRowEnd << "\t"
-          << e.strand << "\t"
-          << graph.originalVertexId[e.refColumnStart] << "\t"
-          << graph.originalVertexId[e.refColumnEnd] << "\t"
-          << e.score << "\t"
-          << e.cigar << "\t"
-          << path_str << "\n";
-      }
+    for (size_t readno = 0; readno < readSet.size(); readno++) {
+      if (bestScoreVector_P1[2 * readno].score >
+          bestScoreVector_P1[2 * readno + 1].score)
+        readSet_P2.push_back(readSet_P1[2 * readno]);
+      else
+        readSet_P2.push_back(readSet_P1[2 * readno + 1]);
     }
 
-  /**
-   * @brief                                 alignment routine
-   * @param[in]   parameters                input parameters
-   * @param[in]   mode                      alignment mode
-   * @param[out]  outputBestScoreVector
-   */
-    int alignToDAG( const Parameters &parameters, 
-                    const MODE mode,  
-                    std::vector< BestScoreInfo > &outputBestScoreVector)
-    {
-      psgl::graphLoader g;
-
-      //Parse all reads into a vector
-      std::vector<std::string> reads;
-      assert (outputBestScoreVector.empty());
-
-      //read metadata
-      std::vector<ContigInfo> qmetadata; 
+    assert(readSet_P2.size() == readSet.size());
 
-      {
-        if (parameters.mode.compare("vg") == 0)
-          g.loadFromVG(parameters.rfile);
-        else if(parameters.mode.compare("txt") == 0)
-          g.loadFromTxt(parameters.rfile);
-        else 
-        {
-          std::cerr << "Invalid format " << parameters.mode << std::endl;
-          exit(1);
-        }
-      }
+    alignToDAGLocal_Phase2(readSet_P2, graph, parameters,
+                           outputBestScoreVector);
 
-      {
-        //TODO: Read query sequences in batches rather than all at once
-        if( !fileExists(parameters.qfile) )
-        {
-          std::cerr << parameters.qfile << " not accessible." << std::endl;
-          exit(1);
-        }
-
-        //Open the file using kseq
-        FILE *file = fopen (parameters.qfile.c_str(), "r");
-        assert(file != NULL);
-        gzFile fp = gzdopen (fileno(file), "r");
-        kseq_t *seq = kseq_init(fp);
-
-        //size of sequence
-        int len;
-
-        while ((len = kseq_read(seq)) >= 0) 
-        {
-          psgl::seqUtils::makeUpperCase(seq->seq.s, len);
-          reads.push_back(seq->seq.s);
+    // auto tick2 = __rdtsc();
+    // std::cout << "TIMER, psgl::alignToDAG, CPU cycles spent in phase 2  = "
+    //           << tick2 - tick1 << ", estimated time (s) = "
+    //           << (tick2 - tick1) * 1.0 / ASSUMED_CPU_FREQ << "\n";
+  }
+}
 
-          //record query name and length
-          qmetadata.push_back( ContigInfo{seq->name.s, (int32_t) seq->seq.l} );
+/**
+ * @brief                                 print alignment results to file
+ * @param[in]   parameters                input parameters
+ * @param[in]   graph
+ * @param[in]   outputBestScoreVector
+ */
+inline void printResultsToFile(
+    const Parameters &parameters, const std::vector<ContigInfo> &qmetadata,
+    const CSR_char_container &graph,
+    const std::vector<BestScoreInfo> &outputBestScoreVector) {
+  std::ofstream outstrm(parameters.ofile);
+
+  assert(qmetadata.size() == outputBestScoreVector.size());
+
+  for (auto &e : outputBestScoreVector) {
+    std::vector<uint> path;
+    std::string path_str = "";
+    path.push_back(graph.originalVertexId[e.refColumnStart].first);
+    path_str += std::to_string(path.back());
+    for (const int32_t c : e.refColumns) {
+      if (c >= e.refColumnStart && c <= e.refColumnEnd) {
+        int32_t n = graph.originalVertexId[c].first;
+        if (n != path.back()) {
+          path.push_back(n);
+          path_str += "-" + std::to_string(path.back());
         }
-
-        //Close the input file
-        kseq_destroy(seq);  
-        gzclose(fp);
-        fclose(file);
       }
-
-      std::cout << "INFO, psgl::alignToDAG, total count of reads = " << reads.size() << std::endl;
-
-      alignToDAG (reads, g.diCharGraph, parameters, mode, outputBestScoreVector);
-
-      //print results
-      printResultsToFile (parameters, qmetadata, g.diCharGraph, outputBestScoreVector);
-
-      return PSGL_STATUS_OK;
     }
+    outstrm << qmetadata[e.qryId].name << "\t" << qmetadata[e.qryId].len << "\t"
+            << e.qryRowStart << "\t" << e.qryRowEnd << "\t" << e.strand << "\t"
+            << graph.originalVertexId[e.refColumnStart] << "\t"
+            << graph.originalVertexId[e.refColumnEnd] << "\t" << e.score << "\t"
+            << e.cigar << "\t" << path_str << "\n";
+  }
 }
 
+} // namespace psgl
+
 #endif
diff --git a/src/include/csr.hpp b/src/include/csr.hpp
index ec71315..3f027bb 100644
--- a/src/include/csr.hpp
+++ b/src/include/csr.hpp
@@ -339,8 +339,8 @@ namespace psgl
 
         topologicalSort(order); 
 
-        std::cout << "INFO, psgl::CSR_container::sort, topological sort computed, bandwidth = " << directedBandwidth(order) << std::endl;
-        std::cout << "INFO, psgl::CSR_container::sort, relabeling graph based on the computed order" << std::endl;
+        // std::cout << "INFO, psgl::CSR_container::sort, topological sort computed, bandwidth = " << directedBandwidth(order) << std::endl;
+        // std::cout << "INFO, psgl::CSR_container::sort, relabeling graph based on the computed order" << std::endl;
 
         //Sorted position to vertex id mapping (reverse order)
         //preserve the old IDs before relabeling for final output reporting
diff --git a/src/include/csr_char.hpp b/src/include/csr_char.hpp
index d1c1f21..91e8100 100644
--- a/src/include/csr_char.hpp
+++ b/src/include/csr_char.hpp
@@ -137,7 +137,7 @@ namespace psgl
         this->verify();
 #endif
 
-        std::cout << "INFO, psgl::CSR_char_container::build, graph converted to CSR format with character labels, n = " << this->numVertices << ", m = " << this->numEdges << std::endl;
+        // std::cout << "INFO, psgl::CSR_char_container::build, graph converted to CSR format with character labels, n = " << this->numVertices << ", m = " << this->numEdges << std::endl;
       }
 
       /**
diff --git a/src/include/graphLoad.hpp b/src/include/graphLoad.hpp
index 45ec88c..558e5f7 100644
--- a/src/include/graphLoad.hpp
+++ b/src/include/graphLoad.hpp
@@ -36,6 +36,52 @@ namespace psgl
       //initialize an empty character labeled di-graph
       CSR_char_container diCharGraph;
 
+  /**
+   * @brief                 load graph from VG graph format
+   * @param[in]  filename
+   * @details               VG tool (https://github.com/vgteam/vg) uses .vg
+   * format to save graphs
+   */
+  void loadFromHG(const bdsg::HashGraph &g) {
+    {
+      // Read vertices in the graph
+      // vertex numbering in vg starts from 1, so adding a dummy vertex with id
+      // '0' we are assuming that vg's vertex ids are contiguous
+      // 1,2,...g.node_size()
+      diGraph.addVertexCount(1);
+      diGraph.initVertexSequence(0, "N");
+
+      // Get total count of vertices
+      diGraph.addVertexCount(g.get_node_count());
+      assert(g.min_node_id() == 1);
+      for (int i = 1; i <= g.get_node_count(); i++) {
+        bdsg::handle_t vg_handle = g.get_handle(i);
+
+        assert(g.get_id(vg_handle) <= g.get_node_count());
+
+        // add vertex to diGraph
+        diGraph.initVertexSequence(g.get_id(vg_handle),
+                                   g.get_sequence(vg_handle));
+      }
+    }
+    // Read edges in the graph
+    {
+      std::vector<std::pair<int32_t, int32_t>> edgeVector;
+
+      g.for_each_edge([&](const bdsg::edge_t &e) {
+        edgeVector.emplace_back(g.get_id(e.first), g.get_id(e.second));
+      });
+
+      diGraph.initEdges(edgeVector);
+    }
+
+    // topological sort
+    this->sortAndVerify();
+
+    // build character-labeled graph
+    diCharGraph.build(this->diGraph);
+  }
+
       /**
        * @brief                 load graph from VG graph format
        * @param[in]  filename
@@ -84,9 +130,9 @@ namespace psgl
             auto vg_edge = g.edge(i);
 
             //todo: add support for bi-directed graphs
-            assert(("Bi-directed graph not supported yet", vg_edge.from_start() == false));
-            assert(("Bi-directed graph not supported yet", vg_edge.to_end() == false));
-            assert(("Graph overlaps not supported yet", vg_edge.overlap() == 0));
+            assert((/*"Bi-directed graph not supported yet",*/ vg_edge.from_start() == false));
+            assert((/*"Bi-directed graph not supported yet",*/ vg_edge.to_end() == false));
+            assert((/*"Graph overlaps not supported yet",*/ vg_edge.overlap() == 0));
 
             //add edge to diGraph
             edgeVector.emplace_back(vg_edge.from(), vg_edge.to());
diff --git a/src/include/utils.hpp b/src/include/utils.hpp
index d2cba59..3eda050 100644
--- a/src/include/utils.hpp
+++ b/src/include/utils.hpp
@@ -57,7 +57,7 @@ namespace psgl
      * @brief   reverse complement of string
      * @note    assumes dest is pre-allocated
      */
-    void reverseComplement(const std::string &src, std::string &dest) 
+    inline void reverseComplement(const std::string &src, std::string &dest)
     {
       assert(src.length() == dest.length());
 
@@ -84,7 +84,7 @@ namespace psgl
      * @brief   reverse string
      * @note    assumes dest is pre-allocated
      */
-    void reverse(const std::string &src, std::string &dest) 
+    inline void reverse(const std::string &src, std::string &dest)
     {
       assert(src.length() == dest.length());
 
@@ -97,7 +97,7 @@ namespace psgl
      * @param[in]   seq     pointer to input sequence
      * @param[in]   len     length of input sequence
      */
-    void makeUpperCase(char* seq, std::size_t len)
+    inline void makeUpperCase(char* seq, std::size_t len)
     {
       for ( int i = 0; i < len; i++ )
       {
@@ -112,7 +112,7 @@ namespace psgl
      * @brief                     string compaction, e.g. replace ..MMMMM.. with ..5M..
      * @param[in/out]     cigar   the cigar string
      */
-    void cigarCompact (std::string &cigar)
+    inline void cigarCompact (std::string &cigar)
     {
       std::string cigarCpy = cigar;
 
@@ -136,7 +136,7 @@ namespace psgl
      * @brief                 compute alignment score from cigar string
      * @param[in]     cigar   the cigar string
      */
-    int32_t cigarScore (const std::string &cigar, const Parameters &parameters)
+    inline int32_t cigarScore (const std::string &cigar, const Parameters &parameters)
     {
       if (cigar.empty()) 
         return 0;
@@ -263,7 +263,7 @@ namespace psgl
   /**
    * @brief     check if file is accessible
    */
-  bool fileExists(const std::string &filename)
+  inline bool fileExists(const std::string &filename)
   {
     std::ifstream infile(filename);
     return infile.good();
@@ -272,7 +272,7 @@ namespace psgl
   /**
    * @brief       print few important execution env. variables
    */
-  void showExecutionEnv()
+  inline void showExecutionEnv()
   {
     std::cout << "--------" << "\n";
 
@@ -325,7 +325,7 @@ namespace psgl
    * @param[in] threadRunTime   vector containing individual thread execution time
    * @return                    string containing min, max and mean
    */
-  std::string printStats (std::vector<double> &threadRunTime)
+  inline std::string printStats (std::vector<double> &threadRunTime)
   {
     auto min = *std::min_element(threadRunTime.begin(), threadRunTime.end());
     auto max = *std::max_element(threadRunTime.begin(), threadRunTime.end());
